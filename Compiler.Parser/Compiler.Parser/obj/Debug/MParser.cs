//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.3
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from C:\Users\mariusg\Documents\Visual Studio 2013\Projects\Compiler\Compiler.Parser\Compiler.Parser\MParser.g4 by ANTLR 4.3

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591

namespace Compiler.Parser {
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using System.Collections.Generic;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.3")]
[System.CLSCompliant(false)]
public partial class MParser : Parser {
	public const int
		Double=12, Mod=32, Void=3, GreaterEqual=24, RightBracket=20, Static=9, 
		This=5, LineComment=46, IntegerConstant=42, LessEqual=22, Colon=37, NotEqual=26, 
		AndAnd=33, Equal=25, For=8, Identifier=41, Int=4, StringLiteral=43, Plus=27, 
		Minus=28, Assign=39, Semi=36, Break=1, Comment=45, New=11, Less=21, LeftBrace=17, 
		Not=35, Dot=40, Interface=14, LeftBracket=19, OrOr=34, StarStar=30, String=13, 
		LeftParen=15, Star=29, Class=2, Return=10, RightParen=16, Whitespace=44, 
		Else=7, Comma=38, If=6, Greater=23, Div=31, RightBrace=18, While=47;
	public static readonly string[] tokenNames = {
		"<INVALID>", "'break'", "'class'", "'void'", "'int'", "'this'", "'if'", 
		"'else'", "'for'", "'static'", "'return'", "'new'", "'double'", "'string'", 
		"'interface'", "'('", "')'", "'{'", "'}'", "'['", "']'", "'<'", "'<='", 
		"'>'", "'>='", "'=='", "'!='", "'+'", "'-'", "'*'", "'**'", "'/'", "'%'", 
		"'&&'", "'||'", "'!'", "';'", "':'", "','", "'='", "'.'", "Identifier", 
		"IntegerConstant", "StringLiteral", "Whitespace", "Comment", "LineComment", 
		"While"
	};
	public const int
		RULE_program = 0, RULE_classDecleration = 1, RULE_interfaceDecleration = 2, 
		RULE_member = 3, RULE_prototype = 4, RULE_variableDecleration = 5, RULE_methodDecleration = 6, 
		RULE_parameters = 7, RULE_variable = 8, RULE_type = 9, RULE_statementBlock = 10, 
		RULE_statement = 11, RULE_ifStatement = 12, RULE_whileStatement = 13, 
		RULE_forStatement = 14, RULE_returnStatement = 15, RULE_breakStatement = 16, 
		RULE_expression = 17, RULE_coreExpression = 18, RULE_creator = 19, RULE_methodCall = 20, 
		RULE_arguments = 21, RULE_constant = 22;
	public static readonly string[] ruleNames = {
		"program", "classDecleration", "interfaceDecleration", "member", "prototype", 
		"variableDecleration", "methodDecleration", "parameters", "variable", 
		"type", "statementBlock", "statement", "ifStatement", "whileStatement", 
		"forStatement", "returnStatement", "breakStatement", "expression", "coreExpression", 
		"creator", "methodCall", "arguments", "constant"
	};

	public override string GrammarFileName { get { return "MParser.g4"; } }

	public override string[] TokenNames { get { return tokenNames; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override string SerializedAtn { get { return _serializedATN; } }

	public MParser(ITokenStream input)
		: base(input)
	{
		_interp = new ParserATNSimulator(this,_ATN);
	}
	public partial class ProgramContext : ParserRuleContext {
		public IReadOnlyList<InterfaceDeclerationContext> interfaceDecleration() {
			return GetRuleContexts<InterfaceDeclerationContext>();
		}
		public ITerminalNode Eof() { return GetToken(MParser.Eof, 0); }
		public ClassDeclerationContext classDecleration(int i) {
			return GetRuleContext<ClassDeclerationContext>(i);
		}
		public IReadOnlyList<ClassDeclerationContext> classDecleration() {
			return GetRuleContexts<ClassDeclerationContext>();
		}
		public InterfaceDeclerationContext interfaceDecleration(int i) {
			return GetRuleContext<InterfaceDeclerationContext>(i);
		}
		public ProgramContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_program; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMParserListener typedListener = listener as IMParserListener;
			if (typedListener != null) typedListener.EnterProgram(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMParserListener typedListener = listener as IMParserListener;
			if (typedListener != null) typedListener.ExitProgram(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMParserVisitor<TResult> typedVisitor = visitor as IMParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitProgram(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ProgramContext program() {
		ProgramContext _localctx = new ProgramContext(_ctx, State);
		EnterRule(_localctx, 0, RULE_program);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 48;
			_errHandler.Sync(this);
			_la = _input.La(1);
			do {
				{
				State = 48;
				switch (_input.La(1)) {
				case Class:
					{
					State = 46; classDecleration();
					}
					break;
				case Interface:
					{
					State = 47; interfaceDecleration();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				State = 50;
				_errHandler.Sync(this);
				_la = _input.La(1);
			} while ( _la==Class || _la==Interface );
			State = 52; Match(Eof);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ClassDeclerationContext : ParserRuleContext {
		public ITerminalNode Colon() { return GetToken(MParser.Colon, 0); }
		public ITerminalNode Class() { return GetToken(MParser.Class, 0); }
		public IReadOnlyList<MemberContext> member() {
			return GetRuleContexts<MemberContext>();
		}
		public ITerminalNode RightBrace() { return GetToken(MParser.RightBrace, 0); }
		public ITerminalNode Identifier(int i) {
			return GetToken(MParser.Identifier, i);
		}
		public IReadOnlyList<ITerminalNode> Identifier() { return GetTokens(MParser.Identifier); }
		public MemberContext member(int i) {
			return GetRuleContext<MemberContext>(i);
		}
		public ITerminalNode LeftBrace() { return GetToken(MParser.LeftBrace, 0); }
		public ClassDeclerationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_classDecleration; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMParserListener typedListener = listener as IMParserListener;
			if (typedListener != null) typedListener.EnterClassDecleration(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMParserListener typedListener = listener as IMParserListener;
			if (typedListener != null) typedListener.ExitClassDecleration(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMParserVisitor<TResult> typedVisitor = visitor as IMParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitClassDecleration(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ClassDeclerationContext classDecleration() {
		ClassDeclerationContext _localctx = new ClassDeclerationContext(_ctx, State);
		EnterRule(_localctx, 2, RULE_classDecleration);
		int _la;
		try {
			State = 76;
			switch ( Interpreter.AdaptivePredict(_input,4,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 54; Match(Class);
				State = 55; Match(Identifier);
				State = 56; Match(Colon);
				State = 57; Match(Identifier);
				State = 58; Match(LeftBrace);
				State = 62;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << Void) | (1L << Int) | (1L << Static) | (1L << Double) | (1L << String) | (1L << Identifier))) != 0)) {
					{
					{
					State = 59; member();
					}
					}
					State = 64;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 65; Match(RightBrace);
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 66; Match(Class);
				State = 67; Match(Identifier);
				State = 68; Match(LeftBrace);
				State = 72;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << Void) | (1L << Int) | (1L << Static) | (1L << Double) | (1L << String) | (1L << Identifier))) != 0)) {
					{
					{
					State = 69; member();
					}
					}
					State = 74;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 75; Match(RightBrace);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class InterfaceDeclerationContext : ParserRuleContext {
		public ITerminalNode Colon() { return GetToken(MParser.Colon, 0); }
		public PrototypeContext prototype(int i) {
			return GetRuleContext<PrototypeContext>(i);
		}
		public ITerminalNode RightBrace() { return GetToken(MParser.RightBrace, 0); }
		public ITerminalNode Identifier(int i) {
			return GetToken(MParser.Identifier, i);
		}
		public IReadOnlyList<ITerminalNode> Identifier() { return GetTokens(MParser.Identifier); }
		public ITerminalNode Interface() { return GetToken(MParser.Interface, 0); }
		public IReadOnlyList<PrototypeContext> prototype() {
			return GetRuleContexts<PrototypeContext>();
		}
		public ITerminalNode LeftBrace() { return GetToken(MParser.LeftBrace, 0); }
		public InterfaceDeclerationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_interfaceDecleration; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMParserListener typedListener = listener as IMParserListener;
			if (typedListener != null) typedListener.EnterInterfaceDecleration(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMParserListener typedListener = listener as IMParserListener;
			if (typedListener != null) typedListener.ExitInterfaceDecleration(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMParserVisitor<TResult> typedVisitor = visitor as IMParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInterfaceDecleration(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public InterfaceDeclerationContext interfaceDecleration() {
		InterfaceDeclerationContext _localctx = new InterfaceDeclerationContext(_ctx, State);
		EnterRule(_localctx, 4, RULE_interfaceDecleration);
		int _la;
		try {
			State = 100;
			switch ( Interpreter.AdaptivePredict(_input,7,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 78; Match(Interface);
				State = 79; Match(Identifier);
				State = 80; Match(Colon);
				State = 81; Match(Identifier);
				State = 82; Match(LeftBrace);
				State = 86;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << Void) | (1L << Int) | (1L << Double) | (1L << String) | (1L << Identifier))) != 0)) {
					{
					{
					State = 83; prototype();
					}
					}
					State = 88;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 89; Match(RightBrace);
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 90; Match(Interface);
				State = 91; Match(Identifier);
				State = 92; Match(LeftBrace);
				State = 96;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << Void) | (1L << Int) | (1L << Double) | (1L << String) | (1L << Identifier))) != 0)) {
					{
					{
					State = 93; prototype();
					}
					}
					State = 98;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 99; Match(RightBrace);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MemberContext : ParserRuleContext {
		public MethodDeclerationContext methodDecleration() {
			return GetRuleContext<MethodDeclerationContext>(0);
		}
		public VariableDeclerationContext variableDecleration() {
			return GetRuleContext<VariableDeclerationContext>(0);
		}
		public MemberContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_member; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMParserListener typedListener = listener as IMParserListener;
			if (typedListener != null) typedListener.EnterMember(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMParserListener typedListener = listener as IMParserListener;
			if (typedListener != null) typedListener.ExitMember(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMParserVisitor<TResult> typedVisitor = visitor as IMParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMember(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MemberContext member() {
		MemberContext _localctx = new MemberContext(_ctx, State);
		EnterRule(_localctx, 6, RULE_member);
		try {
			State = 104;
			switch ( Interpreter.AdaptivePredict(_input,8,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 102; methodDecleration();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 103; variableDecleration();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PrototypeContext : ParserRuleContext {
		public ITerminalNode Semi() { return GetToken(MParser.Semi, 0); }
		public ITerminalNode LeftParen() { return GetToken(MParser.LeftParen, 0); }
		public ITerminalNode RightParen() { return GetToken(MParser.RightParen, 0); }
		public ITerminalNode Identifier() { return GetToken(MParser.Identifier, 0); }
		public TypeContext type() {
			return GetRuleContext<TypeContext>(0);
		}
		public ParametersContext parameters() {
			return GetRuleContext<ParametersContext>(0);
		}
		public ITerminalNode Void() { return GetToken(MParser.Void, 0); }
		public PrototypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_prototype; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMParserListener typedListener = listener as IMParserListener;
			if (typedListener != null) typedListener.EnterPrototype(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMParserListener typedListener = listener as IMParserListener;
			if (typedListener != null) typedListener.ExitPrototype(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMParserVisitor<TResult> typedVisitor = visitor as IMParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPrototype(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PrototypeContext prototype() {
		PrototypeContext _localctx = new PrototypeContext(_ctx, State);
		EnterRule(_localctx, 8, RULE_prototype);
		int _la;
		try {
			State = 123;
			switch (_input.La(1)) {
			case Void:
				EnterOuterAlt(_localctx, 1);
				{
				State = 106; Match(Void);
				State = 107; Match(Identifier);
				State = 108; Match(LeftParen);
				State = 110;
				_la = _input.La(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << Int) | (1L << Double) | (1L << String) | (1L << Identifier))) != 0)) {
					{
					State = 109; parameters();
					}
				}

				State = 112; Match(RightParen);
				State = 113; Match(Semi);
				}
				break;
			case Int:
			case Double:
			case String:
			case Identifier:
				EnterOuterAlt(_localctx, 2);
				{
				State = 114; type(0);
				State = 115; Match(Identifier);
				State = 116; Match(LeftParen);
				State = 118;
				_la = _input.La(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << Int) | (1L << Double) | (1L << String) | (1L << Identifier))) != 0)) {
					{
					State = 117; parameters();
					}
				}

				State = 120; Match(RightParen);
				State = 121; Match(Semi);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class VariableDeclerationContext : ParserRuleContext {
		public ITerminalNode Semi() { return GetToken(MParser.Semi, 0); }
		public ITerminalNode Assign() { return GetToken(MParser.Assign, 0); }
		public ITerminalNode Identifier() { return GetToken(MParser.Identifier, 0); }
		public TypeContext type() {
			return GetRuleContext<TypeContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public VariableDeclerationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_variableDecleration; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMParserListener typedListener = listener as IMParserListener;
			if (typedListener != null) typedListener.EnterVariableDecleration(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMParserListener typedListener = listener as IMParserListener;
			if (typedListener != null) typedListener.ExitVariableDecleration(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMParserVisitor<TResult> typedVisitor = visitor as IMParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVariableDecleration(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public VariableDeclerationContext variableDecleration() {
		VariableDeclerationContext _localctx = new VariableDeclerationContext(_ctx, State);
		EnterRule(_localctx, 10, RULE_variableDecleration);
		try {
			State = 135;
			switch ( Interpreter.AdaptivePredict(_input,12,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 125; type(0);
				State = 126; Match(Identifier);
				State = 127; Match(Assign);
				State = 128; expression(0);
				State = 129; Match(Semi);
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 131; type(0);
				State = 132; Match(Identifier);
				State = 133; Match(Semi);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MethodDeclerationContext : ParserRuleContext {
		public ITerminalNode LeftParen() { return GetToken(MParser.LeftParen, 0); }
		public ITerminalNode Static() { return GetToken(MParser.Static, 0); }
		public ITerminalNode RightParen() { return GetToken(MParser.RightParen, 0); }
		public StatementBlockContext statementBlock() {
			return GetRuleContext<StatementBlockContext>(0);
		}
		public ITerminalNode Identifier() { return GetToken(MParser.Identifier, 0); }
		public TypeContext type() {
			return GetRuleContext<TypeContext>(0);
		}
		public ParametersContext parameters() {
			return GetRuleContext<ParametersContext>(0);
		}
		public ITerminalNode Void() { return GetToken(MParser.Void, 0); }
		public MethodDeclerationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_methodDecleration; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMParserListener typedListener = listener as IMParserListener;
			if (typedListener != null) typedListener.EnterMethodDecleration(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMParserListener typedListener = listener as IMParserListener;
			if (typedListener != null) typedListener.ExitMethodDecleration(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMParserVisitor<TResult> typedVisitor = visitor as IMParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMethodDecleration(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MethodDeclerationContext methodDecleration() {
		MethodDeclerationContext _localctx = new MethodDeclerationContext(_ctx, State);
		EnterRule(_localctx, 12, RULE_methodDecleration);
		int _la;
		try {
			State = 160;
			switch ( Interpreter.AdaptivePredict(_input,17,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 138;
				_la = _input.La(1);
				if (_la==Static) {
					{
					State = 137; Match(Static);
					}
				}

				State = 140; Match(Void);
				State = 141; Match(Identifier);
				State = 142; Match(LeftParen);
				State = 144;
				_la = _input.La(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << Int) | (1L << Double) | (1L << String) | (1L << Identifier))) != 0)) {
					{
					State = 143; parameters();
					}
				}

				State = 146; Match(RightParen);
				State = 147; statementBlock();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 149;
				_la = _input.La(1);
				if (_la==Static) {
					{
					State = 148; Match(Static);
					}
				}

				State = 151; type(0);
				State = 152; Match(Identifier);
				State = 153; Match(LeftParen);
				State = 155;
				_la = _input.La(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << Int) | (1L << Double) | (1L << String) | (1L << Identifier))) != 0)) {
					{
					State = 154; parameters();
					}
				}

				State = 157; Match(RightParen);
				State = 158; statementBlock();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ParametersContext : ParserRuleContext {
		public IReadOnlyList<VariableContext> variable() {
			return GetRuleContexts<VariableContext>();
		}
		public VariableContext variable(int i) {
			return GetRuleContext<VariableContext>(i);
		}
		public ITerminalNode Comma(int i) {
			return GetToken(MParser.Comma, i);
		}
		public IReadOnlyList<ITerminalNode> Comma() { return GetTokens(MParser.Comma); }
		public ParametersContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_parameters; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMParserListener typedListener = listener as IMParserListener;
			if (typedListener != null) typedListener.EnterParameters(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMParserListener typedListener = listener as IMParserListener;
			if (typedListener != null) typedListener.ExitParameters(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMParserVisitor<TResult> typedVisitor = visitor as IMParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParameters(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ParametersContext parameters() {
		ParametersContext _localctx = new ParametersContext(_ctx, State);
		EnterRule(_localctx, 14, RULE_parameters);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 162; variable();
			State = 167;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==Comma) {
				{
				{
				State = 163; Match(Comma);
				State = 164; variable();
				}
				}
				State = 169;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class VariableContext : ParserRuleContext {
		public ITerminalNode Identifier() { return GetToken(MParser.Identifier, 0); }
		public TypeContext type() {
			return GetRuleContext<TypeContext>(0);
		}
		public VariableContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_variable; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMParserListener typedListener = listener as IMParserListener;
			if (typedListener != null) typedListener.EnterVariable(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMParserListener typedListener = listener as IMParserListener;
			if (typedListener != null) typedListener.ExitVariable(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMParserVisitor<TResult> typedVisitor = visitor as IMParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVariable(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public VariableContext variable() {
		VariableContext _localctx = new VariableContext(_ctx, State);
		EnterRule(_localctx, 16, RULE_variable);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 170; type(0);
			State = 171; Match(Identifier);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeContext : ParserRuleContext {
		public ITerminalNode RightBracket() { return GetToken(MParser.RightBracket, 0); }
		public ITerminalNode String() { return GetToken(MParser.String, 0); }
		public ITerminalNode Double() { return GetToken(MParser.Double, 0); }
		public ITerminalNode LeftBracket() { return GetToken(MParser.LeftBracket, 0); }
		public ITerminalNode Identifier() { return GetToken(MParser.Identifier, 0); }
		public TypeContext type() {
			return GetRuleContext<TypeContext>(0);
		}
		public ITerminalNode Int() { return GetToken(MParser.Int, 0); }
		public TypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_type; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMParserListener typedListener = listener as IMParserListener;
			if (typedListener != null) typedListener.EnterType(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMParserListener typedListener = listener as IMParserListener;
			if (typedListener != null) typedListener.ExitType(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMParserVisitor<TResult> typedVisitor = visitor as IMParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitType(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypeContext type() {
		return type(0);
	}

	private TypeContext type(int _p) {
		ParserRuleContext _parentctx = _ctx;
		int _parentState = State;
		TypeContext _localctx = new TypeContext(_ctx, _parentState);
		TypeContext _prevctx = _localctx;
		int _startState = 18;
		EnterRecursionRule(_localctx, 18, RULE_type, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 178;
			switch (_input.La(1)) {
			case Int:
				{
				State = 174; Match(Int);
				}
				break;
			case String:
				{
				State = 175; Match(String);
				}
				break;
			case Double:
				{
				State = 176; Match(Double);
				}
				break;
			case Identifier:
				{
				State = 177; Match(Identifier);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			_ctx.stop = _input.Lt(-1);
			State = 185;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,20,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					if ( _parseListeners!=null ) TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					{
					_localctx = new TypeContext(_parentctx, _parentState);
					PushNewRecursionContext(_localctx, _startState, RULE_type);
					State = 180;
					if (!(Precpred(_ctx, 2))) throw new FailedPredicateException(this, "Precpred(_ctx, 2)");
					State = 181; Match(LeftBracket);
					State = 182; Match(RightBracket);
					}
					} 
				}
				State = 187;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,20,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class StatementBlockContext : ParserRuleContext {
		public IReadOnlyList<StatementContext> statement() {
			return GetRuleContexts<StatementContext>();
		}
		public ITerminalNode RightBrace() { return GetToken(MParser.RightBrace, 0); }
		public StatementContext statement(int i) {
			return GetRuleContext<StatementContext>(i);
		}
		public ITerminalNode LeftBrace() { return GetToken(MParser.LeftBrace, 0); }
		public StatementBlockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_statementBlock; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMParserListener typedListener = listener as IMParserListener;
			if (typedListener != null) typedListener.EnterStatementBlock(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMParserListener typedListener = listener as IMParserListener;
			if (typedListener != null) typedListener.ExitStatementBlock(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMParserVisitor<TResult> typedVisitor = visitor as IMParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStatementBlock(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StatementBlockContext statementBlock() {
		StatementBlockContext _localctx = new StatementBlockContext(_ctx, State);
		EnterRule(_localctx, 20, RULE_statementBlock);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 188; Match(LeftBrace);
			State = 192;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << Break) | (1L << Int) | (1L << This) | (1L << If) | (1L << For) | (1L << Return) | (1L << New) | (1L << Double) | (1L << String) | (1L << LeftParen) | (1L << LeftBrace) | (1L << Minus) | (1L << Not) | (1L << Identifier) | (1L << IntegerConstant) | (1L << StringLiteral) | (1L << While))) != 0)) {
				{
				{
				State = 189; statement();
				}
				}
				State = 194;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 195; Match(RightBrace);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StatementContext : ParserRuleContext {
		public ITerminalNode Semi() { return GetToken(MParser.Semi, 0); }
		public BreakStatementContext breakStatement() {
			return GetRuleContext<BreakStatementContext>(0);
		}
		public IfStatementContext ifStatement() {
			return GetRuleContext<IfStatementContext>(0);
		}
		public StatementBlockContext statementBlock() {
			return GetRuleContext<StatementBlockContext>(0);
		}
		public ReturnStatementContext returnStatement() {
			return GetRuleContext<ReturnStatementContext>(0);
		}
		public VariableDeclerationContext variableDecleration() {
			return GetRuleContext<VariableDeclerationContext>(0);
		}
		public WhileStatementContext whileStatement() {
			return GetRuleContext<WhileStatementContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ForStatementContext forStatement() {
			return GetRuleContext<ForStatementContext>(0);
		}
		public StatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMParserListener typedListener = listener as IMParserListener;
			if (typedListener != null) typedListener.EnterStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMParserListener typedListener = listener as IMParserListener;
			if (typedListener != null) typedListener.ExitStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMParserVisitor<TResult> typedVisitor = visitor as IMParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StatementContext statement() {
		StatementContext _localctx = new StatementContext(_ctx, State);
		EnterRule(_localctx, 22, RULE_statement);
		try {
			State = 207;
			switch ( Interpreter.AdaptivePredict(_input,22,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 197; expression(0);
				State = 198; Match(Semi);
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 200; ifStatement();
				}
				break;

			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 201; whileStatement();
				}
				break;

			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 202; forStatement();
				}
				break;

			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 203; returnStatement();
				}
				break;

			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 204; breakStatement();
				}
				break;

			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 205; variableDecleration();
				}
				break;

			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 206; statementBlock();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IfStatementContext : ParserRuleContext {
		public IReadOnlyList<StatementContext> statement() {
			return GetRuleContexts<StatementContext>();
		}
		public ITerminalNode LeftParen() { return GetToken(MParser.LeftParen, 0); }
		public ITerminalNode Else() { return GetToken(MParser.Else, 0); }
		public ITerminalNode RightParen() { return GetToken(MParser.RightParen, 0); }
		public ITerminalNode If() { return GetToken(MParser.If, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public StatementContext statement(int i) {
			return GetRuleContext<StatementContext>(i);
		}
		public IfStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ifStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMParserListener typedListener = listener as IMParserListener;
			if (typedListener != null) typedListener.EnterIfStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMParserListener typedListener = listener as IMParserListener;
			if (typedListener != null) typedListener.ExitIfStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMParserVisitor<TResult> typedVisitor = visitor as IMParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIfStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IfStatementContext ifStatement() {
		IfStatementContext _localctx = new IfStatementContext(_ctx, State);
		EnterRule(_localctx, 24, RULE_ifStatement);
		try {
			State = 223;
			switch ( Interpreter.AdaptivePredict(_input,23,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 209; Match(If);
				State = 210; Match(LeftParen);
				State = 211; expression(0);
				State = 212; Match(RightParen);
				State = 213; statement();
				State = 214; Match(Else);
				State = 215; statement();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 217; Match(If);
				State = 218; Match(LeftParen);
				State = 219; expression(0);
				State = 220; Match(RightParen);
				State = 221; statement();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class WhileStatementContext : ParserRuleContext {
		public StatementContext statement() {
			return GetRuleContext<StatementContext>(0);
		}
		public ITerminalNode While() { return GetToken(MParser.While, 0); }
		public ITerminalNode LeftParen() { return GetToken(MParser.LeftParen, 0); }
		public ITerminalNode RightParen() { return GetToken(MParser.RightParen, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public WhileStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_whileStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMParserListener typedListener = listener as IMParserListener;
			if (typedListener != null) typedListener.EnterWhileStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMParserListener typedListener = listener as IMParserListener;
			if (typedListener != null) typedListener.ExitWhileStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMParserVisitor<TResult> typedVisitor = visitor as IMParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWhileStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public WhileStatementContext whileStatement() {
		WhileStatementContext _localctx = new WhileStatementContext(_ctx, State);
		EnterRule(_localctx, 26, RULE_whileStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 225; Match(While);
			State = 226; Match(LeftParen);
			State = 227; expression(0);
			State = 228; Match(RightParen);
			State = 229; statement();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ForStatementContext : ParserRuleContext {
		public ITerminalNode For() { return GetToken(MParser.For, 0); }
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode LeftParen() { return GetToken(MParser.LeftParen, 0); }
		public ITerminalNode RightParen() { return GetToken(MParser.RightParen, 0); }
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ITerminalNode Comma(int i) {
			return GetToken(MParser.Comma, i);
		}
		public IReadOnlyList<ITerminalNode> Comma() { return GetTokens(MParser.Comma); }
		public ForStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_forStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMParserListener typedListener = listener as IMParserListener;
			if (typedListener != null) typedListener.EnterForStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMParserListener typedListener = listener as IMParserListener;
			if (typedListener != null) typedListener.ExitForStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMParserVisitor<TResult> typedVisitor = visitor as IMParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitForStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ForStatementContext forStatement() {
		ForStatementContext _localctx = new ForStatementContext(_ctx, State);
		EnterRule(_localctx, 28, RULE_forStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 231; Match(For);
			State = 232; Match(LeftParen);
			State = 233; expression(0);
			State = 234; Match(Comma);
			State = 235; expression(0);
			State = 236; Match(Comma);
			State = 238;
			_la = _input.La(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << This) | (1L << New) | (1L << LeftParen) | (1L << Minus) | (1L << Not) | (1L << Identifier) | (1L << IntegerConstant) | (1L << StringLiteral))) != 0)) {
				{
				State = 237; expression(0);
				}
			}

			State = 240; Match(RightParen);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ReturnStatementContext : ParserRuleContext {
		public ITerminalNode Semi() { return GetToken(MParser.Semi, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode Return() { return GetToken(MParser.Return, 0); }
		public ReturnStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_returnStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMParserListener typedListener = listener as IMParserListener;
			if (typedListener != null) typedListener.EnterReturnStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMParserListener typedListener = listener as IMParserListener;
			if (typedListener != null) typedListener.ExitReturnStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMParserVisitor<TResult> typedVisitor = visitor as IMParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitReturnStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ReturnStatementContext returnStatement() {
		ReturnStatementContext _localctx = new ReturnStatementContext(_ctx, State);
		EnterRule(_localctx, 30, RULE_returnStatement);
		try {
			State = 248;
			switch ( Interpreter.AdaptivePredict(_input,25,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 242; Match(Return);
				State = 243; expression(0);
				State = 244; Match(Semi);
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 246; Match(Return);
				State = 247; Match(Semi);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BreakStatementContext : ParserRuleContext {
		public ITerminalNode Semi() { return GetToken(MParser.Semi, 0); }
		public ITerminalNode Break() { return GetToken(MParser.Break, 0); }
		public BreakStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_breakStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMParserListener typedListener = listener as IMParserListener;
			if (typedListener != null) typedListener.EnterBreakStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMParserListener typedListener = listener as IMParserListener;
			if (typedListener != null) typedListener.ExitBreakStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMParserVisitor<TResult> typedVisitor = visitor as IMParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBreakStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BreakStatementContext breakStatement() {
		BreakStatementContext _localctx = new BreakStatementContext(_ctx, State);
		EnterRule(_localctx, 32, RULE_breakStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 250; Match(Break);
			State = 251; Match(Semi);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionContext : ParserRuleContext {
		public ITerminalNode Less() { return GetToken(MParser.Less, 0); }
		public ITerminalNode NotEqual() { return GetToken(MParser.NotEqual, 0); }
		public ITerminalNode Div() { return GetToken(MParser.Div, 0); }
		public ITerminalNode LeftBracket() { return GetToken(MParser.LeftBracket, 0); }
		public ITerminalNode Not() { return GetToken(MParser.Not, 0); }
		public ITerminalNode Dot() { return GetToken(MParser.Dot, 0); }
		public ITerminalNode Star() { return GetToken(MParser.Star, 0); }
		public ITerminalNode AndAnd() { return GetToken(MParser.AndAnd, 0); }
		public ITerminalNode Greater() { return GetToken(MParser.Greater, 0); }
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ITerminalNode StarStar() { return GetToken(MParser.StarStar, 0); }
		public ITerminalNode OrOr() { return GetToken(MParser.OrOr, 0); }
		public ITerminalNode Minus() { return GetToken(MParser.Minus, 0); }
		public CreatorContext creator() {
			return GetRuleContext<CreatorContext>(0);
		}
		public ITerminalNode RightBracket() { return GetToken(MParser.RightBracket, 0); }
		public ITerminalNode Mod() { return GetToken(MParser.Mod, 0); }
		public ITerminalNode LessEqual() { return GetToken(MParser.LessEqual, 0); }
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode Plus() { return GetToken(MParser.Plus, 0); }
		public CoreExpressionContext coreExpression() {
			return GetRuleContext<CoreExpressionContext>(0);
		}
		public ITerminalNode Assign() { return GetToken(MParser.Assign, 0); }
		public MethodCallContext methodCall() {
			return GetRuleContext<MethodCallContext>(0);
		}
		public ITerminalNode Equal() { return GetToken(MParser.Equal, 0); }
		public ITerminalNode GreaterEqual() { return GetToken(MParser.GreaterEqual, 0); }
		public ExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMParserListener typedListener = listener as IMParserListener;
			if (typedListener != null) typedListener.EnterExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMParserListener typedListener = listener as IMParserListener;
			if (typedListener != null) typedListener.ExitExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMParserVisitor<TResult> typedVisitor = visitor as IMParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionContext expression() {
		return expression(0);
	}

	private ExpressionContext expression(int _p) {
		ParserRuleContext _parentctx = _ctx;
		int _parentState = State;
		ExpressionContext _localctx = new ExpressionContext(_ctx, _parentState);
		ExpressionContext _prevctx = _localctx;
		int _startState = 34;
		EnterRecursionRule(_localctx, 34, RULE_expression, _p);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 261;
			switch ( Interpreter.AdaptivePredict(_input,26,_ctx) ) {
			case 1:
				{
				State = 254; Match(Minus);
				State = 255; expression(7);
				}
				break;

			case 2:
				{
				State = 256; Match(Not);
				State = 257; expression(2);
				}
				break;

			case 3:
				{
				State = 258; coreExpression();
				}
				break;

			case 4:
				{
				State = 259; methodCall();
				}
				break;

			case 5:
				{
				State = 260; creator();
				}
				break;
			}
			_ctx.stop = _input.Lt(-1);
			State = 297;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,28,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					if ( _parseListeners!=null ) TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 295;
					switch ( Interpreter.AdaptivePredict(_input,27,_ctx) ) {
					case 1:
						{
						_localctx = new ExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 263;
						if (!(Precpred(_ctx, 13))) throw new FailedPredicateException(this, "Precpred(_ctx, 13)");
						State = 264; Match(Dot);
						State = 265; expression(14);
						}
						break;

					case 2:
						{
						_localctx = new ExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 266;
						if (!(Precpred(_ctx, 10))) throw new FailedPredicateException(this, "Precpred(_ctx, 10)");
						State = 267; Match(StarStar);
						State = 268; expression(11);
						}
						break;

					case 3:
						{
						_localctx = new ExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 269;
						if (!(Precpred(_ctx, 9))) throw new FailedPredicateException(this, "Precpred(_ctx, 9)");
						State = 270;
						_la = _input.La(1);
						if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << Star) | (1L << Div) | (1L << Mod))) != 0)) ) {
						_errHandler.RecoverInline(this);
						}
						Consume();
						State = 271; expression(10);
						}
						break;

					case 4:
						{
						_localctx = new ExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 272;
						if (!(Precpred(_ctx, 8))) throw new FailedPredicateException(this, "Precpred(_ctx, 8)");
						State = 273;
						_la = _input.La(1);
						if ( !(_la==Plus || _la==Minus) ) {
						_errHandler.RecoverInline(this);
						}
						Consume();
						State = 274; expression(9);
						}
						break;

					case 5:
						{
						_localctx = new ExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 275;
						if (!(Precpred(_ctx, 6))) throw new FailedPredicateException(this, "Precpred(_ctx, 6)");
						State = 276;
						_la = _input.La(1);
						if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << Less) | (1L << LessEqual) | (1L << Greater) | (1L << GreaterEqual))) != 0)) ) {
						_errHandler.RecoverInline(this);
						}
						Consume();
						State = 277; expression(7);
						}
						break;

					case 6:
						{
						_localctx = new ExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 278;
						if (!(Precpred(_ctx, 5))) throw new FailedPredicateException(this, "Precpred(_ctx, 5)");
						State = 279;
						_la = _input.La(1);
						if ( !(_la==Equal || _la==NotEqual) ) {
						_errHandler.RecoverInline(this);
						}
						Consume();
						State = 280; expression(6);
						}
						break;

					case 7:
						{
						_localctx = new ExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 281;
						if (!(Precpred(_ctx, 4))) throw new FailedPredicateException(this, "Precpred(_ctx, 4)");
						State = 282; Match(AndAnd);
						State = 283; expression(5);
						}
						break;

					case 8:
						{
						_localctx = new ExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 284;
						if (!(Precpred(_ctx, 3))) throw new FailedPredicateException(this, "Precpred(_ctx, 3)");
						State = 285; Match(OrOr);
						State = 286; expression(4);
						}
						break;

					case 9:
						{
						_localctx = new ExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 287;
						if (!(Precpred(_ctx, 1))) throw new FailedPredicateException(this, "Precpred(_ctx, 1)");
						State = 288; Match(Assign);
						State = 289; expression(1);
						}
						break;

					case 10:
						{
						_localctx = new ExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 290;
						if (!(Precpred(_ctx, 14))) throw new FailedPredicateException(this, "Precpred(_ctx, 14)");
						State = 291; Match(LeftBracket);
						State = 292; expression(0);
						State = 293; Match(RightBracket);
						}
						break;
					}
					} 
				}
				State = 299;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,28,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class CoreExpressionContext : ParserRuleContext {
		public ITerminalNode LeftParen() { return GetToken(MParser.LeftParen, 0); }
		public ITerminalNode This() { return GetToken(MParser.This, 0); }
		public ITerminalNode RightParen() { return GetToken(MParser.RightParen, 0); }
		public ITerminalNode Identifier() { return GetToken(MParser.Identifier, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ConstantContext constant() {
			return GetRuleContext<ConstantContext>(0);
		}
		public CoreExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_coreExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMParserListener typedListener = listener as IMParserListener;
			if (typedListener != null) typedListener.EnterCoreExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMParserListener typedListener = listener as IMParserListener;
			if (typedListener != null) typedListener.ExitCoreExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMParserVisitor<TResult> typedVisitor = visitor as IMParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCoreExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CoreExpressionContext coreExpression() {
		CoreExpressionContext _localctx = new CoreExpressionContext(_ctx, State);
		EnterRule(_localctx, 36, RULE_coreExpression);
		try {
			State = 307;
			switch (_input.La(1)) {
			case LeftParen:
				EnterOuterAlt(_localctx, 1);
				{
				State = 300; Match(LeftParen);
				State = 301; expression(0);
				State = 302; Match(RightParen);
				}
				break;
			case This:
				EnterOuterAlt(_localctx, 2);
				{
				State = 304; Match(This);
				}
				break;
			case IntegerConstant:
			case StringLiteral:
				EnterOuterAlt(_localctx, 3);
				{
				State = 305; constant();
				}
				break;
			case Identifier:
				EnterOuterAlt(_localctx, 4);
				{
				State = 306; Match(Identifier);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreatorContext : ParserRuleContext {
		public ITerminalNode RightBracket() { return GetToken(MParser.RightBracket, 0); }
		public ITerminalNode New() { return GetToken(MParser.New, 0); }
		public ITerminalNode LeftParen() { return GetToken(MParser.LeftParen, 0); }
		public ITerminalNode RightParen() { return GetToken(MParser.RightParen, 0); }
		public ITerminalNode LeftBracket() { return GetToken(MParser.LeftBracket, 0); }
		public TypeContext type() {
			return GetRuleContext<TypeContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public CreatorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_creator; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMParserListener typedListener = listener as IMParserListener;
			if (typedListener != null) typedListener.EnterCreator(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMParserListener typedListener = listener as IMParserListener;
			if (typedListener != null) typedListener.ExitCreator(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMParserVisitor<TResult> typedVisitor = visitor as IMParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreator(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CreatorContext creator() {
		CreatorContext _localctx = new CreatorContext(_ctx, State);
		EnterRule(_localctx, 38, RULE_creator);
		try {
			State = 320;
			switch ( Interpreter.AdaptivePredict(_input,30,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 309; Match(New);
				State = 310; type(0);
				State = 311; Match(LeftBracket);
				State = 312; expression(0);
				State = 313; Match(RightBracket);
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 315; Match(New);
				State = 316; type(0);
				State = 317; Match(LeftParen);
				State = 318; Match(RightParen);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MethodCallContext : ParserRuleContext {
		public ITerminalNode LeftParen() { return GetToken(MParser.LeftParen, 0); }
		public ITerminalNode RightParen() { return GetToken(MParser.RightParen, 0); }
		public ITerminalNode Identifier() { return GetToken(MParser.Identifier, 0); }
		public ArgumentsContext arguments() {
			return GetRuleContext<ArgumentsContext>(0);
		}
		public MethodCallContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_methodCall; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMParserListener typedListener = listener as IMParserListener;
			if (typedListener != null) typedListener.EnterMethodCall(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMParserListener typedListener = listener as IMParserListener;
			if (typedListener != null) typedListener.ExitMethodCall(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMParserVisitor<TResult> typedVisitor = visitor as IMParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMethodCall(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MethodCallContext methodCall() {
		MethodCallContext _localctx = new MethodCallContext(_ctx, State);
		EnterRule(_localctx, 40, RULE_methodCall);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 322; Match(Identifier);
			State = 323; Match(LeftParen);
			State = 325;
			_la = _input.La(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << This) | (1L << New) | (1L << LeftParen) | (1L << Minus) | (1L << Not) | (1L << Identifier) | (1L << IntegerConstant) | (1L << StringLiteral))) != 0)) {
				{
				State = 324; arguments();
				}
			}

			State = 327; Match(RightParen);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ArgumentsContext : ParserRuleContext {
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ITerminalNode Comma(int i) {
			return GetToken(MParser.Comma, i);
		}
		public IReadOnlyList<ITerminalNode> Comma() { return GetTokens(MParser.Comma); }
		public ArgumentsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_arguments; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMParserListener typedListener = listener as IMParserListener;
			if (typedListener != null) typedListener.EnterArguments(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMParserListener typedListener = listener as IMParserListener;
			if (typedListener != null) typedListener.ExitArguments(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMParserVisitor<TResult> typedVisitor = visitor as IMParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitArguments(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ArgumentsContext arguments() {
		ArgumentsContext _localctx = new ArgumentsContext(_ctx, State);
		EnterRule(_localctx, 42, RULE_arguments);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 329; expression(0);
			State = 334;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==Comma) {
				{
				{
				State = 330; Match(Comma);
				State = 331; expression(0);
				}
				}
				State = 336;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConstantContext : ParserRuleContext {
		public ITerminalNode IntegerConstant() { return GetToken(MParser.IntegerConstant, 0); }
		public ITerminalNode StringLiteral() { return GetToken(MParser.StringLiteral, 0); }
		public ConstantContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_constant; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMParserListener typedListener = listener as IMParserListener;
			if (typedListener != null) typedListener.EnterConstant(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMParserListener typedListener = listener as IMParserListener;
			if (typedListener != null) typedListener.ExitConstant(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMParserVisitor<TResult> typedVisitor = visitor as IMParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConstant(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ConstantContext constant() {
		ConstantContext _localctx = new ConstantContext(_ctx, State);
		EnterRule(_localctx, 44, RULE_constant);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 337;
			_la = _input.La(1);
			if ( !(_la==IntegerConstant || _la==StringLiteral) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public override bool Sempred(RuleContext _localctx, int ruleIndex, int predIndex) {
		switch (ruleIndex) {
		case 9: return type_sempred((TypeContext)_localctx, predIndex);

		case 17: return expression_sempred((ExpressionContext)_localctx, predIndex);
		}
		return true;
	}
	private bool expression_sempred(ExpressionContext _localctx, int predIndex) {
		switch (predIndex) {
		case 1: return Precpred(_ctx, 13);

		case 2: return Precpred(_ctx, 10);

		case 3: return Precpred(_ctx, 9);

		case 4: return Precpred(_ctx, 8);

		case 5: return Precpred(_ctx, 6);

		case 6: return Precpred(_ctx, 5);

		case 7: return Precpred(_ctx, 4);

		case 8: return Precpred(_ctx, 3);

		case 9: return Precpred(_ctx, 1);

		case 10: return Precpred(_ctx, 14);
		}
		return true;
	}
	private bool type_sempred(TypeContext _localctx, int predIndex) {
		switch (predIndex) {
		case 0: return Precpred(_ctx, 2);
		}
		return true;
	}

	public static readonly string _serializedATN =
		"\x3\xAF6F\x8320\x479D\xB75C\x4880\x1605\x191C\xAB37\x3\x31\x156\x4\x2"+
		"\t\x2\x4\x3\t\x3\x4\x4\t\x4\x4\x5\t\x5\x4\x6\t\x6\x4\a\t\a\x4\b\t\b\x4"+
		"\t\t\t\x4\n\t\n\x4\v\t\v\x4\f\t\f\x4\r\t\r\x4\xE\t\xE\x4\xF\t\xF\x4\x10"+
		"\t\x10\x4\x11\t\x11\x4\x12\t\x12\x4\x13\t\x13\x4\x14\t\x14\x4\x15\t\x15"+
		"\x4\x16\t\x16\x4\x17\t\x17\x4\x18\t\x18\x3\x2\x3\x2\x6\x2\x33\n\x2\r\x2"+
		"\xE\x2\x34\x3\x2\x3\x2\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\a\x3?\n\x3"+
		"\f\x3\xE\x3\x42\v\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\a\x3I\n\x3\f\x3\xE"+
		"\x3L\v\x3\x3\x3\x5\x3O\n\x3\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\a\x4W"+
		"\n\x4\f\x4\xE\x4Z\v\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\a\x4\x61\n\x4\f\x4"+
		"\xE\x4\x64\v\x4\x3\x4\x5\x4g\n\x4\x3\x5\x3\x5\x5\x5k\n\x5\x3\x6\x3\x6"+
		"\x3\x6\x3\x6\x5\x6q\n\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x5\x6y\n"+
		"\x6\x3\x6\x3\x6\x3\x6\x5\x6~\n\x6\x3\a\x3\a\x3\a\x3\a\x3\a\x3\a\x3\a\x3"+
		"\a\x3\a\x3\a\x5\a\x8A\n\a\x3\b\x5\b\x8D\n\b\x3\b\x3\b\x3\b\x3\b\x5\b\x93"+
		"\n\b\x3\b\x3\b\x3\b\x5\b\x98\n\b\x3\b\x3\b\x3\b\x3\b\x5\b\x9E\n\b\x3\b"+
		"\x3\b\x3\b\x5\b\xA3\n\b\x3\t\x3\t\x3\t\a\t\xA8\n\t\f\t\xE\t\xAB\v\t\x3"+
		"\n\x3\n\x3\n\x3\v\x3\v\x3\v\x3\v\x3\v\x5\v\xB5\n\v\x3\v\x3\v\x3\v\a\v"+
		"\xBA\n\v\f\v\xE\v\xBD\v\v\x3\f\x3\f\a\f\xC1\n\f\f\f\xE\f\xC4\v\f\x3\f"+
		"\x3\f\x3\r\x3\r\x3\r\x3\r\x3\r\x3\r\x3\r\x3\r\x3\r\x3\r\x5\r\xD2\n\r\x3"+
		"\xE\x3\xE\x3\xE\x3\xE\x3\xE\x3\xE\x3\xE\x3\xE\x3\xE\x3\xE\x3\xE\x3\xE"+
		"\x3\xE\x3\xE\x5\xE\xE2\n\xE\x3\xF\x3\xF\x3\xF\x3\xF\x3\xF\x3\xF\x3\x10"+
		"\x3\x10\x3\x10\x3\x10\x3\x10\x3\x10\x3\x10\x5\x10\xF1\n\x10\x3\x10\x3"+
		"\x10\x3\x11\x3\x11\x3\x11\x3\x11\x3\x11\x3\x11\x5\x11\xFB\n\x11\x3\x12"+
		"\x3\x12\x3\x12\x3\x13\x3\x13\x3\x13\x3\x13\x3\x13\x3\x13\x3\x13\x3\x13"+
		"\x5\x13\x108\n\x13\x3\x13\x3\x13\x3\x13\x3\x13\x3\x13\x3\x13\x3\x13\x3"+
		"\x13\x3\x13\x3\x13\x3\x13\x3\x13\x3\x13\x3\x13\x3\x13\x3\x13\x3\x13\x3"+
		"\x13\x3\x13\x3\x13\x3\x13\x3\x13\x3\x13\x3\x13\x3\x13\x3\x13\x3\x13\x3"+
		"\x13\x3\x13\x3\x13\x3\x13\x3\x13\a\x13\x12A\n\x13\f\x13\xE\x13\x12D\v"+
		"\x13\x3\x14\x3\x14\x3\x14\x3\x14\x3\x14\x3\x14\x3\x14\x5\x14\x136\n\x14"+
		"\x3\x15\x3\x15\x3\x15\x3\x15\x3\x15\x3\x15\x3\x15\x3\x15\x3\x15\x3\x15"+
		"\x3\x15\x5\x15\x143\n\x15\x3\x16\x3\x16\x3\x16\x5\x16\x148\n\x16\x3\x16"+
		"\x3\x16\x3\x17\x3\x17\x3\x17\a\x17\x14F\n\x17\f\x17\xE\x17\x152\v\x17"+
		"\x3\x18\x3\x18\x3\x18\x2\x2\x4\x14$\x19\x2\x2\x4\x2\x6\x2\b\x2\n\x2\f"+
		"\x2\xE\x2\x10\x2\x12\x2\x14\x2\x16\x2\x18\x2\x1A\x2\x1C\x2\x1E\x2 \x2"+
		"\"\x2$\x2&\x2(\x2*\x2,\x2.\x2\x2\a\x4\x2\x1F\x1F!\"\x3\x2\x1D\x1E\x3\x2"+
		"\x17\x1A\x3\x2\x1B\x1C\x3\x2,-\x174\x2\x32\x3\x2\x2\x2\x4N\x3\x2\x2\x2"+
		"\x6\x66\x3\x2\x2\x2\bj\x3\x2\x2\x2\n}\x3\x2\x2\x2\f\x89\x3\x2\x2\x2\xE"+
		"\xA2\x3\x2\x2\x2\x10\xA4\x3\x2\x2\x2\x12\xAC\x3\x2\x2\x2\x14\xB4\x3\x2"+
		"\x2\x2\x16\xBE\x3\x2\x2\x2\x18\xD1\x3\x2\x2\x2\x1A\xE1\x3\x2\x2\x2\x1C"+
		"\xE3\x3\x2\x2\x2\x1E\xE9\x3\x2\x2\x2 \xFA\x3\x2\x2\x2\"\xFC\x3\x2\x2\x2"+
		"$\x107\x3\x2\x2\x2&\x135\x3\x2\x2\x2(\x142\x3\x2\x2\x2*\x144\x3\x2\x2"+
		"\x2,\x14B\x3\x2\x2\x2.\x153\x3\x2\x2\x2\x30\x33\x5\x4\x3\x2\x31\x33\x5"+
		"\x6\x4\x2\x32\x30\x3\x2\x2\x2\x32\x31\x3\x2\x2\x2\x33\x34\x3\x2\x2\x2"+
		"\x34\x32\x3\x2\x2\x2\x34\x35\x3\x2\x2\x2\x35\x36\x3\x2\x2\x2\x36\x37\a"+
		"\x2\x2\x3\x37\x3\x3\x2\x2\x2\x38\x39\a\x4\x2\x2\x39:\a+\x2\x2:;\a\'\x2"+
		"\x2;<\a+\x2\x2<@\a\x13\x2\x2=?\x5\b\x5\x2>=\x3\x2\x2\x2?\x42\x3\x2\x2"+
		"\x2@>\x3\x2\x2\x2@\x41\x3\x2\x2\x2\x41\x43\x3\x2\x2\x2\x42@\x3\x2\x2\x2"+
		"\x43O\a\x14\x2\x2\x44\x45\a\x4\x2\x2\x45\x46\a+\x2\x2\x46J\a\x13\x2\x2"+
		"GI\x5\b\x5\x2HG\x3\x2\x2\x2IL\x3\x2\x2\x2JH\x3\x2\x2\x2JK\x3\x2\x2\x2"+
		"KM\x3\x2\x2\x2LJ\x3\x2\x2\x2MO\a\x14\x2\x2N\x38\x3\x2\x2\x2N\x44\x3\x2"+
		"\x2\x2O\x5\x3\x2\x2\x2PQ\a\x10\x2\x2QR\a+\x2\x2RS\a\'\x2\x2ST\a+\x2\x2"+
		"TX\a\x13\x2\x2UW\x5\n\x6\x2VU\x3\x2\x2\x2WZ\x3\x2\x2\x2XV\x3\x2\x2\x2"+
		"XY\x3\x2\x2\x2Y[\x3\x2\x2\x2ZX\x3\x2\x2\x2[g\a\x14\x2\x2\\]\a\x10\x2\x2"+
		"]^\a+\x2\x2^\x62\a\x13\x2\x2_\x61\x5\n\x6\x2`_\x3\x2\x2\x2\x61\x64\x3"+
		"\x2\x2\x2\x62`\x3\x2\x2\x2\x62\x63\x3\x2\x2\x2\x63\x65\x3\x2\x2\x2\x64"+
		"\x62\x3\x2\x2\x2\x65g\a\x14\x2\x2\x66P\x3\x2\x2\x2\x66\\\x3\x2\x2\x2g"+
		"\a\x3\x2\x2\x2hk\x5\xE\b\x2ik\x5\f\a\x2jh\x3\x2\x2\x2ji\x3\x2\x2\x2k\t"+
		"\x3\x2\x2\x2lm\a\x5\x2\x2mn\a+\x2\x2np\a\x11\x2\x2oq\x5\x10\t\x2po\x3"+
		"\x2\x2\x2pq\x3\x2\x2\x2qr\x3\x2\x2\x2rs\a\x12\x2\x2s~\a&\x2\x2tu\x5\x14"+
		"\v\x2uv\a+\x2\x2vx\a\x11\x2\x2wy\x5\x10\t\x2xw\x3\x2\x2\x2xy\x3\x2\x2"+
		"\x2yz\x3\x2\x2\x2z{\a\x12\x2\x2{|\a&\x2\x2|~\x3\x2\x2\x2}l\x3\x2\x2\x2"+
		"}t\x3\x2\x2\x2~\v\x3\x2\x2\x2\x7F\x80\x5\x14\v\x2\x80\x81\a+\x2\x2\x81"+
		"\x82\a)\x2\x2\x82\x83\x5$\x13\x2\x83\x84\a&\x2\x2\x84\x8A\x3\x2\x2\x2"+
		"\x85\x86\x5\x14\v\x2\x86\x87\a+\x2\x2\x87\x88\a&\x2\x2\x88\x8A\x3\x2\x2"+
		"\x2\x89\x7F\x3\x2\x2\x2\x89\x85\x3\x2\x2\x2\x8A\r\x3\x2\x2\x2\x8B\x8D"+
		"\a\v\x2\x2\x8C\x8B\x3\x2\x2\x2\x8C\x8D\x3\x2\x2\x2\x8D\x8E\x3\x2\x2\x2"+
		"\x8E\x8F\a\x5\x2\x2\x8F\x90\a+\x2\x2\x90\x92\a\x11\x2\x2\x91\x93\x5\x10"+
		"\t\x2\x92\x91\x3\x2\x2\x2\x92\x93\x3\x2\x2\x2\x93\x94\x3\x2\x2\x2\x94"+
		"\x95\a\x12\x2\x2\x95\xA3\x5\x16\f\x2\x96\x98\a\v\x2\x2\x97\x96\x3\x2\x2"+
		"\x2\x97\x98\x3\x2\x2\x2\x98\x99\x3\x2\x2\x2\x99\x9A\x5\x14\v\x2\x9A\x9B"+
		"\a+\x2\x2\x9B\x9D\a\x11\x2\x2\x9C\x9E\x5\x10\t\x2\x9D\x9C\x3\x2\x2\x2"+
		"\x9D\x9E\x3\x2\x2\x2\x9E\x9F\x3\x2\x2\x2\x9F\xA0\a\x12\x2\x2\xA0\xA1\x5"+
		"\x16\f\x2\xA1\xA3\x3\x2\x2\x2\xA2\x8C\x3\x2\x2\x2\xA2\x97\x3\x2\x2\x2"+
		"\xA3\xF\x3\x2\x2\x2\xA4\xA9\x5\x12\n\x2\xA5\xA6\a(\x2\x2\xA6\xA8\x5\x12"+
		"\n\x2\xA7\xA5\x3\x2\x2\x2\xA8\xAB\x3\x2\x2\x2\xA9\xA7\x3\x2\x2\x2\xA9"+
		"\xAA\x3\x2\x2\x2\xAA\x11\x3\x2\x2\x2\xAB\xA9\x3\x2\x2\x2\xAC\xAD\x5\x14"+
		"\v\x2\xAD\xAE\a+\x2\x2\xAE\x13\x3\x2\x2\x2\xAF\xB0\b\v\x1\x2\xB0\xB5\a"+
		"\x6\x2\x2\xB1\xB5\a\xF\x2\x2\xB2\xB5\a\xE\x2\x2\xB3\xB5\a+\x2\x2\xB4\xAF"+
		"\x3\x2\x2\x2\xB4\xB1\x3\x2\x2\x2\xB4\xB2\x3\x2\x2\x2\xB4\xB3\x3\x2\x2"+
		"\x2\xB5\xBB\x3\x2\x2\x2\xB6\xB7\f\x4\x2\x2\xB7\xB8\a\x15\x2\x2\xB8\xBA"+
		"\a\x16\x2\x2\xB9\xB6\x3\x2\x2\x2\xBA\xBD\x3\x2\x2\x2\xBB\xB9\x3\x2\x2"+
		"\x2\xBB\xBC\x3\x2\x2\x2\xBC\x15\x3\x2\x2\x2\xBD\xBB\x3\x2\x2\x2\xBE\xC2"+
		"\a\x13\x2\x2\xBF\xC1\x5\x18\r\x2\xC0\xBF\x3\x2\x2\x2\xC1\xC4\x3\x2\x2"+
		"\x2\xC2\xC0\x3\x2\x2\x2\xC2\xC3\x3\x2\x2\x2\xC3\xC5\x3\x2\x2\x2\xC4\xC2"+
		"\x3\x2\x2\x2\xC5\xC6\a\x14\x2\x2\xC6\x17\x3\x2\x2\x2\xC7\xC8\x5$\x13\x2"+
		"\xC8\xC9\a&\x2\x2\xC9\xD2\x3\x2\x2\x2\xCA\xD2\x5\x1A\xE\x2\xCB\xD2\x5"+
		"\x1C\xF\x2\xCC\xD2\x5\x1E\x10\x2\xCD\xD2\x5 \x11\x2\xCE\xD2\x5\"\x12\x2"+
		"\xCF\xD2\x5\f\a\x2\xD0\xD2\x5\x16\f\x2\xD1\xC7\x3\x2\x2\x2\xD1\xCA\x3"+
		"\x2\x2\x2\xD1\xCB\x3\x2\x2\x2\xD1\xCC\x3\x2\x2\x2\xD1\xCD\x3\x2\x2\x2"+
		"\xD1\xCE\x3\x2\x2\x2\xD1\xCF\x3\x2\x2\x2\xD1\xD0\x3\x2\x2\x2\xD2\x19\x3"+
		"\x2\x2\x2\xD3\xD4\a\b\x2\x2\xD4\xD5\a\x11\x2\x2\xD5\xD6\x5$\x13\x2\xD6"+
		"\xD7\a\x12\x2\x2\xD7\xD8\x5\x18\r\x2\xD8\xD9\a\t\x2\x2\xD9\xDA\x5\x18"+
		"\r\x2\xDA\xE2\x3\x2\x2\x2\xDB\xDC\a\b\x2\x2\xDC\xDD\a\x11\x2\x2\xDD\xDE"+
		"\x5$\x13\x2\xDE\xDF\a\x12\x2\x2\xDF\xE0\x5\x18\r\x2\xE0\xE2\x3\x2\x2\x2"+
		"\xE1\xD3\x3\x2\x2\x2\xE1\xDB\x3\x2\x2\x2\xE2\x1B\x3\x2\x2\x2\xE3\xE4\a"+
		"\x31\x2\x2\xE4\xE5\a\x11\x2\x2\xE5\xE6\x5$\x13\x2\xE6\xE7\a\x12\x2\x2"+
		"\xE7\xE8\x5\x18\r\x2\xE8\x1D\x3\x2\x2\x2\xE9\xEA\a\n\x2\x2\xEA\xEB\a\x11"+
		"\x2\x2\xEB\xEC\x5$\x13\x2\xEC\xED\a(\x2\x2\xED\xEE\x5$\x13\x2\xEE\xF0"+
		"\a(\x2\x2\xEF\xF1\x5$\x13\x2\xF0\xEF\x3\x2\x2\x2\xF0\xF1\x3\x2\x2\x2\xF1"+
		"\xF2\x3\x2\x2\x2\xF2\xF3\a\x12\x2\x2\xF3\x1F\x3\x2\x2\x2\xF4\xF5\a\f\x2"+
		"\x2\xF5\xF6\x5$\x13\x2\xF6\xF7\a&\x2\x2\xF7\xFB\x3\x2\x2\x2\xF8\xF9\a"+
		"\f\x2\x2\xF9\xFB\a&\x2\x2\xFA\xF4\x3\x2\x2\x2\xFA\xF8\x3\x2\x2\x2\xFB"+
		"!\x3\x2\x2\x2\xFC\xFD\a\x3\x2\x2\xFD\xFE\a&\x2\x2\xFE#\x3\x2\x2\x2\xFF"+
		"\x100\b\x13\x1\x2\x100\x101\a\x1E\x2\x2\x101\x108\x5$\x13\t\x102\x103"+
		"\a%\x2\x2\x103\x108\x5$\x13\x4\x104\x108\x5&\x14\x2\x105\x108\x5*\x16"+
		"\x2\x106\x108\x5(\x15\x2\x107\xFF\x3\x2\x2\x2\x107\x102\x3\x2\x2\x2\x107"+
		"\x104\x3\x2\x2\x2\x107\x105\x3\x2\x2\x2\x107\x106\x3\x2\x2\x2\x108\x12B"+
		"\x3\x2\x2\x2\x109\x10A\f\xF\x2\x2\x10A\x10B\a*\x2\x2\x10B\x12A\x5$\x13"+
		"\x10\x10C\x10D\f\f\x2\x2\x10D\x10E\a \x2\x2\x10E\x12A\x5$\x13\r\x10F\x110"+
		"\f\v\x2\x2\x110\x111\t\x2\x2\x2\x111\x12A\x5$\x13\f\x112\x113\f\n\x2\x2"+
		"\x113\x114\t\x3\x2\x2\x114\x12A\x5$\x13\v\x115\x116\f\b\x2\x2\x116\x117"+
		"\t\x4\x2\x2\x117\x12A\x5$\x13\t\x118\x119\f\a\x2\x2\x119\x11A\t\x5\x2"+
		"\x2\x11A\x12A\x5$\x13\b\x11B\x11C\f\x6\x2\x2\x11C\x11D\a#\x2\x2\x11D\x12A"+
		"\x5$\x13\a\x11E\x11F\f\x5\x2\x2\x11F\x120\a$\x2\x2\x120\x12A\x5$\x13\x6"+
		"\x121\x122\f\x3\x2\x2\x122\x123\a)\x2\x2\x123\x12A\x5$\x13\x3\x124\x125"+
		"\f\x10\x2\x2\x125\x126\a\x15\x2\x2\x126\x127\x5$\x13\x2\x127\x128\a\x16"+
		"\x2\x2\x128\x12A\x3\x2\x2\x2\x129\x109\x3\x2\x2\x2\x129\x10C\x3\x2\x2"+
		"\x2\x129\x10F\x3\x2\x2\x2\x129\x112\x3\x2\x2\x2\x129\x115\x3\x2\x2\x2"+
		"\x129\x118\x3\x2\x2\x2\x129\x11B\x3\x2\x2\x2\x129\x11E\x3\x2\x2\x2\x129"+
		"\x121\x3\x2\x2\x2\x129\x124\x3\x2\x2\x2\x12A\x12D\x3\x2\x2\x2\x12B\x129"+
		"\x3\x2\x2\x2\x12B\x12C\x3\x2\x2\x2\x12C%\x3\x2\x2\x2\x12D\x12B\x3\x2\x2"+
		"\x2\x12E\x12F\a\x11\x2\x2\x12F\x130\x5$\x13\x2\x130\x131\a\x12\x2\x2\x131"+
		"\x136\x3\x2\x2\x2\x132\x136\a\a\x2\x2\x133\x136\x5.\x18\x2\x134\x136\a"+
		"+\x2\x2\x135\x12E\x3\x2\x2\x2\x135\x132\x3\x2\x2\x2\x135\x133\x3\x2\x2"+
		"\x2\x135\x134\x3\x2\x2\x2\x136\'\x3\x2\x2\x2\x137\x138\a\r\x2\x2\x138"+
		"\x139\x5\x14\v\x2\x139\x13A\a\x15\x2\x2\x13A\x13B\x5$\x13\x2\x13B\x13C"+
		"\a\x16\x2\x2\x13C\x143\x3\x2\x2\x2\x13D\x13E\a\r\x2\x2\x13E\x13F\x5\x14"+
		"\v\x2\x13F\x140\a\x11\x2\x2\x140\x141\a\x12\x2\x2\x141\x143\x3\x2\x2\x2"+
		"\x142\x137\x3\x2\x2\x2\x142\x13D\x3\x2\x2\x2\x143)\x3\x2\x2\x2\x144\x145"+
		"\a+\x2\x2\x145\x147\a\x11\x2\x2\x146\x148\x5,\x17\x2\x147\x146\x3\x2\x2"+
		"\x2\x147\x148\x3\x2\x2\x2\x148\x149\x3\x2\x2\x2\x149\x14A\a\x12\x2\x2"+
		"\x14A+\x3\x2\x2\x2\x14B\x150\x5$\x13\x2\x14C\x14D\a(\x2\x2\x14D\x14F\x5"+
		"$\x13\x2\x14E\x14C\x3\x2\x2\x2\x14F\x152\x3\x2\x2\x2\x150\x14E\x3\x2\x2"+
		"\x2\x150\x151\x3\x2\x2\x2\x151-\x3\x2\x2\x2\x152\x150\x3\x2\x2\x2\x153"+
		"\x154\t\x6\x2\x2\x154/\x3\x2\x2\x2#\x32\x34@JNX\x62\x66jpx}\x89\x8C\x92"+
		"\x97\x9D\xA2\xA9\xB4\xBB\xC2\xD1\xE1\xF0\xFA\x107\x129\x12B\x135\x142"+
		"\x147\x150";
	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN.ToCharArray());
}
} // namespace Compiler.Parser
